const mongoose = require('mongoose');

const routeSchema = new mongoose.Schema({
  // Basic Route Information
  routeNumber: {
    type: String,
    required: true,
    trim: true,
    uppercase: true
  },
  routeName: {
    type: String,
    required: true,
    trim: true
  },
  
  // Starting and Ending Points
  startingPoint: {
    city: {
      type: String,
      required: true,
      trim: true
    },
    location: {
      type: String,
      required: true,
      trim: true
    },
    coordinates: {
      latitude: Number,
      longitude: Number
    }
  },
  
  endingPoint: {
    city: {
      type: String,
      required: true,
      trim: true
    },
    location: {
      type: String,
      required: true,
      trim: true
    },
    coordinates: {
      latitude: Number,
      longitude: Number
    }
  },
  
  // Route Details
  totalDistance: {
    type: Number,
    required: true,
    min: 0
  },
  estimatedDuration: {
    type: Number, // in minutes
    required: true,
    min: 0
  },
  
  // Enhanced Intermediate Stops with Distance from Previous
  stops: [{
    stopId: {
      type: String,
      required: true,
      trim: true
    },
    stopName: {
      type: String,
      required: true,
      trim: true
    },
    name: {
      type: String,
      required: true,
      trim: true
    },
    city: {
      type: String,
      required: true,
      trim: true
    },
    location: {
      type: String,
      required: true,
      trim: true
    },
    stopNumber: {
      type: Number,
      required: true
    },
    sequence: {
      type: Number,
      required: true
    },
    distanceFromPrev: {
      type: Number,
      required: true,
      min: 0
    },
    distanceFromStart: {
      type: Number,
      required: true
    },
    estimatedArrival: {
      type: Number, // minutes from start
      required: true
    },
    coordinates: {
      latitude: Number,
      longitude: Number
    },
    lat: {
      type: Number,
      required: true
    },
    lng: {
      type: Number,
      required: true
    },
    isActive: {
      type: Boolean,
      default: true
    },
    isAutoGenerated: {
      type: Boolean,
      default: false
    },
    isManual: {
      type: Boolean,
      default: false
    },
    isCustom: {
      type: Boolean,
      default: false
    }
  }],

  // Legacy intermediateStops for backward compatibility
  intermediateStops: [{
    city: {
      type: String,
      required: true,
      trim: true
    },
    location: {
      type: String,
      required: true,
      trim: true
    },
    stopNumber: {
      type: Number,
      required: true
    },
    distanceFromStart: {
      type: Number,
      required: true
    },
    estimatedArrival: {
      type: Number, // minutes from start
      required: true
    },
    coordinates: {
      latitude: Number,
      longitude: Number
    }
  }],
  
  // Depot Information
  depot: {
    depotId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Depot',
      required: true
    },
    depotName: {
      type: String,
      required: true
    },
    depotLocation: {
      type: String,
      required: true
    }
  },
  
  // Scheduling Information
  schedules: [{
    scheduleId: {
      type: String,
      required: true,
      unique: true
    },
    departureTime: {
      type: String, // Format: "HH:MM"
      required: true
    },
    arrivalTime: {
      type: String, // Format: "HH:MM"
      required: true
    },
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'monthly', 'custom'],
      default: 'daily'
    },
    daysOfWeek: [{
      type: String,
      enum: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
    }],
    customDates: [{
      type: Date
    }],
    isActive: {
      type: Boolean,
      default: true
    },
    effectiveFrom: {
      type: Date,
      default: Date.now
    },
    effectiveTo: {
      type: Date
    },
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Route Status
  status: {
    type: String,
    enum: ['active', 'inactive', 'maintenance', 'suspended'],
    default: 'active'
  },
  
  // Bus Assignment
  assignedBuses: [{
    busId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Bus'
    },
    busNumber: String,
    capacity: Number,
    busType: String
  }],
  
  // Enhanced Pricing Information
  baseFare: {
    type: Number,
    required: true,
    min: 0
  },
  farePerKm: {
    type: Number,
    required: true,
    min: 0
  },
  fareStructure: [{
    fromStop: String,
    toStop: String,
    fare: Number
  }],
  
  // Auto-generated Fare Matrix for Stop-to-Stop Pricing
  fareMatrix: {
    type: Map,
    of: Map,
    default: new Map()
  },
  
  // Fare calculation metadata
  fareCalculation: {
    lastCalculated: {
      type: Date,
      default: Date.now
    },
    farePerKmUsed: {
      type: Number
    },
    totalStops: {
      type: Number
    }
  },
  
  // Route Features
  features: [{
    type: String,
    enum: ['AC', 'WiFi', 'USB_Charging', 'Entertainment', 'Refreshments', 'Wheelchair_Accessible']
  }],

  // Map-based route data
  routePolyline: {
    type: String, // Encoded polyline string from OSRM
    default: null
  },
  
  routeCoordinates: [{
    lat: Number,
    lng: Number
  }],

  // Bus type for fare calculation
  busType: {
    type: String,
    enum: ['ordinary', 'fast_passenger', 'super_fast', 'ac', 'volvo', 'garuda'],
    default: 'ordinary'
  },

  // Enhanced fare matrix for all stop combinations
  enhancedFareMatrix: {
    type: Map,
    of: Map,
    default: new Map()
  },

  // Route creation method
  creationMethod: {
    type: String,
    enum: ['manual', 'map_based', 'bulk_import'],
    default: 'manual'
  },

  // Route validation status
  validationStatus: {
    type: String,
    enum: ['pending', 'validated', 'invalid'],
    default: 'pending'
  },

  // Route quality metrics
  routeQuality: {
    distanceAccuracy: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    durationAccuracy: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    stopCoverage: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  
  // Metadata
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  updatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Indexes for better performance
routeSchema.index({ routeNumber: 1 });
routeSchema.index({ 'startingPoint.city': 1 });
routeSchema.index({ 'endingPoint.city': 1 });
routeSchema.index({ 'depot.depotId': 1 });
routeSchema.index({ status: 1 });
routeSchema.index({ isActive: 1 });
routeSchema.index({ busType: 1 });
routeSchema.index({ creationMethod: 1 });
routeSchema.index({ validationStatus: 1 });
routeSchema.index({ 'stops.stopId': 1 });
routeSchema.index({ 'stops.lat': 1, 'stops.lng': 1 });

// Virtual for full route description
routeSchema.virtual('fullRouteDescription').get(function() {
  return `${this.startingPoint.city} â†’ ${this.endingPoint.city}`;
});

// Virtual for total stops
routeSchema.virtual('totalStops').get(function() {
  return this.intermediateStops.length + 2; // +2 for start and end points
});

// Pre-save middleware to generate schedule IDs
routeSchema.pre('save', function(next) {
  if (this.schedules && this.schedules.length > 0) {
    this.schedules.forEach(schedule => {
      if (!schedule.scheduleId) {
        schedule.scheduleId = `SCH_${this.routeNumber}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
    });
  }
  next();
});

// Method to add new schedule
routeSchema.methods.addSchedule = function(scheduleData) {
  const newSchedule = {
    ...scheduleData,
    scheduleId: `SCH_${this.routeNumber}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    createdAt: new Date()
  };
  
  this.schedules.push(newSchedule);
  return this.save();
};

// Method to update schedule
routeSchema.methods.updateSchedule = function(scheduleId, updateData) {
  const schedule = this.schedules.id(scheduleId);
  if (schedule) {
    Object.assign(schedule, updateData);
    schedule.updatedAt = new Date();
    return this.save();
  }
  throw new Error('Schedule not found');
};

// Method to remove schedule
routeSchema.methods.removeSchedule = function(scheduleId) {
  this.schedules = this.schedules.filter(schedule => schedule.scheduleId !== scheduleId);
  return this.save();
};

// Static method to find routes by cities
routeSchema.statics.findByCities = function(fromCity, toCity) {
  return this.find({
    'startingPoint.city': { $regex: fromCity, $options: 'i' },
    'endingPoint.city': { $regex: toCity, $options: 'i' },
    isActive: true,
    status: 'active'
  });
};

// Static method to find routes by depot
routeSchema.statics.findByDepot = function(depotId) {
  return this.find({
    'depot.depotId': depotId,
    isActive: true
  });
};

// Method to calculate fare matrix for all stop combinations
routeSchema.methods.calculateFareMatrix = function(farePerKm) {
  const stops = this.stops || this.intermediateStops;
  if (!stops || stops.length === 0) {
    return new Map();
  }

  const fareMatrix = new Map();
  const ratePerKm = farePerKm || this.farePerKm || 0;

  // Add start and end points to stops array for calculation
  const allStops = [
    {
      stopName: this.startingPoint.location,
      distanceFromStart: 0,
      stopNumber: 0
    },
    ...stops,
    {
      stopName: this.endingPoint.location,
      distanceFromStart: this.totalDistance,
      stopNumber: stops.length + 1
    }
  ];

  // Calculate fare for each stop-to-stop combination
  for (let i = 0; i < allStops.length; i++) {
    const fromStop = allStops[i];
    const stopMap = new Map();
    
    for (let j = i + 1; j < allStops.length; j++) {
      const toStop = allStops[j];
      const distance = toStop.distanceFromStart - fromStop.distanceFromStart;
      const fare = Math.round(distance * ratePerKm * 100) / 100; // Round to 2 decimal places
      
      stopMap.set(toStop.stopName, {
        distance: distance,
        fare: fare,
        fromStopNumber: fromStop.stopNumber,
        toStopNumber: toStop.stopNumber
      });
    }
    
    if (stopMap.size > 0) {
      fareMatrix.set(fromStop.stopName, stopMap);
    }
  }

  // Update fare calculation metadata
  this.fareMatrix = fareMatrix;
  this.fareCalculation = {
    lastCalculated: new Date(),
    farePerKmUsed: ratePerKm,
    totalStops: allStops.length
  };

  return fareMatrix;
};

// Method to get fare between two stops
routeSchema.methods.getFareBetweenStops = function(fromStopName, toStopName) {
  if (!this.fareMatrix || this.fareMatrix.size === 0) {
    // Calculate fare matrix if not exists
    this.calculateFareMatrix();
  }

  const fromStopMap = this.fareMatrix.get(fromStopName);
  if (!fromStopMap) {
    return null;
  }

  const fareData = fromStopMap.get(toStopName);
  return fareData ? fareData.fare : null;
};

// Method to get all stops for this route
routeSchema.methods.getAllStops = function() {
  const stops = this.stops || this.intermediateStops;
  return [
    {
      stopName: this.startingPoint.location,
      city: this.startingPoint.city,
      stopNumber: 0,
      distanceFromStart: 0,
      isActive: true
    },
    ...stops,
    {
      stopName: this.endingPoint.location,
      city: this.endingPoint.city,
      stopNumber: stops.length + 1,
      distanceFromStart: this.totalDistance,
      isActive: true
    }
  ];
};

// Method to calculate enhanced fare matrix with bus type variations
routeSchema.methods.calculateEnhancedFareMatrix = function(busTypeFares = null) {
  const defaultBusTypeFares = {
    ordinary: { baseFare: 1.0, farePerKm: 1.5 },
    fast_passenger: { baseFare: 2.0, farePerKm: 1.8 },
    super_fast: { baseFare: 3.0, farePerKm: 2.0 },
    ac: { baseFare: 5.0, farePerKm: 3.5 },
    volvo: { baseFare: 8.0, farePerKm: 5.0 },
    garuda: { baseFare: 10.0, farePerKm: 6.0 }
  };
  
  const fares = busTypeFares || defaultBusTypeFares;
  const stops = this.stops || this.intermediateStops;
  
  if (!stops || stops.length === 0) {
    return new Map();
  }

  const fareMatrix = new Map();
  
  // Add start and end points to stops array for calculation
  const allStops = [
    {
      stopId: 'START',
      name: this.startingPoint.location,
      distanceFromStart: 0,
      stopNumber: 0
    },
    ...stops,
    {
      stopId: 'END',
      name: this.endingPoint.location,
      distanceFromStart: this.totalDistance,
      stopNumber: stops.length + 1
    }
  ];

  // Calculate fare for each stop-to-stop combination for each bus type
  for (let i = 0; i < allStops.length; i++) {
    const fromStop = allStops[i];
    const stopMap = new Map();
    
    for (let j = i + 1; j < allStops.length; j++) {
      const toStop = allStops[j];
      const distance = toStop.distanceFromStart - fromStop.distanceFromStart;
      
      // Calculate fare for each bus type
      const busTypeFares = {};
      Object.keys(fares).forEach(busType => {
        const policy = fares[busType];
        busTypeFares[busType] = Math.round((policy.baseFare + (distance * policy.farePerKm)) * 100) / 100;
      });
      
      stopMap.set(toStop.name, {
        distance,
        busTypeFares,
        fromStopNumber: fromStop.stopNumber,
        toStopNumber: toStop.stopNumber,
        fromStopId: fromStop.stopId,
        toStopId: toStop.stopId
      });
    }
    
    if (stopMap.size > 0) {
      fareMatrix.set(fromStop.name, stopMap);
    }
  }

  // Update enhanced fare matrix
  this.enhancedFareMatrix = fareMatrix;
  
  // Update fare calculation metadata
  this.fareCalculation = {
    lastCalculated: new Date(),
    totalStops: allStops.length,
    busTypesCalculated: Object.keys(fares),
    calculationMethod: 'enhanced_with_bus_types'
  };

  return fareMatrix;
};

// Method to get fare between two stops for a specific bus type
routeSchema.methods.getFareBetweenStops = function(fromStopName, toStopName, busType = 'ordinary') {
  if (!this.enhancedFareMatrix || this.enhancedFareMatrix.size === 0) {
    // Calculate fare matrix if not exists
    this.calculateEnhancedFareMatrix();
  }

  const fromStopMap = this.enhancedFareMatrix.get(fromStopName);
  if (!fromStopMap) {
    return null;
  }

  const fareData = fromStopMap.get(toStopName);
  return fareData ? fareData.busTypeFares[busType] : null;
};

// Method to validate route quality
routeSchema.methods.validateRouteQuality = function() {
  const stops = this.stops || this.intermediateStops;
  let qualityScore = {
    distanceAccuracy: 0,
    durationAccuracy: 0,
    stopCoverage: 0
  };
  
  // Calculate distance accuracy (compare calculated vs actual)
  if (this.totalDistance > 0) {
    const expectedDistance = stops.reduce((acc, stop) => acc + (stop.distanceFromPrev || 0), 0);
    const accuracy = Math.max(0, 100 - Math.abs(expectedDistance - this.totalDistance) / this.totalDistance * 100);
    qualityScore.distanceAccuracy = Math.round(accuracy);
  }
  
  // Calculate duration accuracy (basic estimation)
  if (this.estimatedDuration > 0 && this.totalDistance > 0) {
    const expectedDuration = this.totalDistance * 1.5; // Assume 40 km/h average speed
    const accuracy = Math.max(0, 100 - Math.abs(expectedDuration - this.estimatedDuration) / this.estimatedDuration * 100);
    qualityScore.durationAccuracy = Math.round(accuracy);
  }
  
  // Calculate stop coverage (optimal number of stops based on distance)
  const optimalStops = Math.max(2, Math.min(15, Math.floor(this.totalDistance / 20))); // 1 stop per 20km
  const actualStops = stops.length;
  const coverage = Math.max(0, 100 - Math.abs(optimalStops - actualStops) / optimalStops * 100);
  qualityScore.stopCoverage = Math.round(coverage);
  
  this.routeQuality = qualityScore;
  this.validationStatus = qualityScore.distanceAccuracy > 80 ? 'validated' : 'pending';
  
  return qualityScore;
};

const Route = mongoose.model('Route', routeSchema);

module.exports = Route;
