import React, { useState, useEffect, useCallback } from 'react';
// import { useLocation } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Calendar, Plus, Download, Search, Filter, 
  Edit, Trash2, Eye, CheckCircle,
  RefreshCw, Users, Clock,
  X, DollarSign, Bus, Play, Sparkles,
  CalendarDays, Timer, UserCheck, MapPin, Navigation,
  Route, Zap, Save
} from 'lucide-react';
import { toast } from 'react-hot-toast';
import { apiFetch } from '../../utils/api';

const StreamlinedTripManagement = () => {
  const [trips, setTrips] = useState([]);
  const [routes, setRoutes] = useState([]);
  const [buses, setBuses] = useState([]);
  const [drivers, setDrivers] = useState([]);
  const [conductors, setConductors] = useState([]);
  const [depots, setDepots] = useState([]);
  const [loading, setLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [dateFilter, setDateFilter] = useState('');
  // const location = useLocation(); // unused

  // Pagination
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(24);
  const [total, setTotal] = useState(0);
  const [statsCounts, setStatsCounts] = useState({ total: 0, scheduled: 0, running: 0, completed: 0 });
  const [routeFilter, setRouteFilter] = useState('all');
  const [viewMode, setViewMode] = useState('all'); // all | live
  // Assign modal state
  const [showAssignModal, setShowAssignModal] = useState(false);
  const [assignMode, setAssignMode] = useState('now'); // now | date
  const [assignForm, setAssignForm] = useState({
    tripId: '',
    routeId: '',
    busId: '',
    driverId: '',
    scheduledDate: '',
    scheduledTime: ''
  });

  // Enhanced Route Management States
  const [showRouteBuilder, setShowRouteBuilder] = useState(false);
  const [routeBuilderForm, setRouteBuilderForm] = useState({
    routeNumber: '',
    routeName: '',
    startLocation: '',
    endLocation: '',
    startCoords: null,
    endCoords: null,
    depotId: '',
    busType: 'standard',
    farePerKm: 2.5,
    routePolyline: null,
    autoGeneratedStops: [],
    totalDistance: 0,
    estimatedDuration: 0
  });
  const [isGeneratingRoute, setIsGeneratingRoute] = useState(false);

  // Live scheduling modal & auto-schedule
  const [autoDailyKerala] = useState(() => {
    try { return localStorage.getItem('autoDailyKerala') === 'true'; } catch { return false; }
  });
  
  // Form states
  const [showSingleAddModal, setShowSingleAddModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showAutoSchedulerModal, setShowAutoSchedulerModal] = useState(false);
  const [selectedTrip, setSelectedTrip] = useState(null);
  
  // Bulk operations
  const [selectedTrips, setSelectedTrips] = useState([]);
  
  // Trip form data
  const [tripForm, setTripForm] = useState({
    routeId: '',
    busId: '',
    driverId: '',
    conductorId: '',
    serviceDate: '',
    startTime: '',
    endTime: '',
    fare: 0,
    capacity: 0,
    status: 'scheduled',
    depotId: '',
    notes: '',
    bookingOpen: true,
    bookingCloseTime: '',
    cancellationPolicy: {
      hoursBeforeDeparture: 2,
      refundPercentage: 80
    }
  });

  // Auto scheduler form
  const [schedulerForm, setSchedulerForm] = useState({
    targetDate: new Date().toISOString().slice(0, 10), // Default to today
    depotIds: [],
    maxTripsPerRoute: 5,
    timeGap: 30, // minutes between trips
    autoAssignCrew: true,
    autoAssignBuses: true,
    generateReports: true
  });

  // Helper functions - defined early to avoid hoisting issues
  const decodePolyline = useCallback((encoded) => {
    const points = [];
    let index = 0;
    const len = encoded.length;
    let lat = 0;
    let lng = 0;

    while (index < len) {
      let b, shift = 0, result = 0;
      do {
        b = encoded.charCodeAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
      lat += dlat;

      shift = 0;
      result = 0;
      do {
        b = encoded.charCodeAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
      lng += dlng;

      points.push({ lat: lat / 1e5, lng: lng / 1e5 });
    }

    return points;
  }, []);

  const calculateDistance = useCallback((lat1, lng1, lat2, lng2) => {
    const R = 6371; // Earth's radius in kilometers
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }, []);

  const reverseGeocode = useCallback(async (lat, lng) => {
    try {
      // Use Google Maps Geocoding API
      if (window.google && window.google.maps) {
        const geocoder = new window.google.maps.Geocoder();
        const latlng = new window.google.maps.LatLng(lat, lng);
        
        return new Promise((resolve) => {
          geocoder.geocode({ location: latlng }, (results, status) => {
            if (status === 'OK' && results[0]) {
              const result = results[0];
              const addressComponents = result.address_components || [];
              
              // Extract city from address components
              let city = 'Unknown';
              for (const component of addressComponents) {
                if (component.types.includes('locality') || 
                    component.types.includes('administrative_area_level_2') ||
                    component.types.includes('administrative_area_level_3')) {
                  city = component.long_name;
                  break;
                }
              }
              
              resolve({
                name: result.formatted_address.split(',')[0] || result.formatted_address,
                city: city,
                display_name: result.formatted_address
              });
            } else {
              resolve(null);
            }
          });
        });
      } else {
        // Fallback if Google Maps not loaded
        return null;
      }
    } catch (error) {
      console.error('Reverse geocoding error:', error);
      return null;
    }
  }, []);

  // moved effects below after definitions to avoid temporal dead zone

  // Auto-refresh counts periodically (initialized after fetchCounts is defined at bottom)

  // Auto-select first depot when depots are loaded
  useEffect(() => {
    if (depots.length > 0 && !routeBuilderForm.depotId) {
      setRouteBuilderForm(prev => ({
        ...prev,
        depotId: depots[0]._id
      }));
    }
  }, [depots, routeBuilderForm.depotId]);

  useEffect(() => {
    if (!autoDailyKerala) return;
    try {
      const today = new Date().toISOString().slice(0,10);
      const lastRun = localStorage.getItem('autoDailyKerala.lastRun');
      if (lastRun === today) return; // already ran today
      (async () => {
        try {
          await apiFetch('/api/auto-scheduler/mass-schedule', {
            method: 'POST',
            body: JSON.stringify({ date: today, maxTripsPerRoute: 4, timeGap: 30, autoAssignCrew: true, autoAssignBuses: true, optimizeForDemand: true, region: 'KERALA' })
          });
          localStorage.setItem('autoDailyKerala.lastRun', today);
          await startTripsForDate(today);
        } catch (e) {
          console.error('Auto daily Kerala scheduling failed', e);
        }
      })();
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoDailyKerala]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      params.set('page', String(page));
      params.set('limit', String(limit));
      if (searchTerm) params.set('search', searchTerm.trim());
      if (statusFilter !== 'all') params.set('status', statusFilter);

      // Date filtering for admin backend expects dateFrom/dateTo
      const addRangeFor = (yyyyMmDd) => {
        const d = new Date(yyyyMmDd);
        const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0).toISOString();
        const end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999).toISOString();
        params.set('dateFrom', start);
        params.set('dateTo', end);
      };

      if (dateFilter) {
        addRangeFor(dateFilter);
      }
      if (viewMode === 'live' && !dateFilter) {
        // Show all running trips across dates (no date restriction)
        params.set('status', 'running');
      }

      // Try with params first
      let tripsRes = await apiFetch('/api/admin/trips?' + params.toString(), { suppressError: true });
      let payload = tripsRes?.data?.data || tripsRes?.data || {};
      let tripsRaw = payload.trips || payload.data || (Array.isArray(payload) ? payload : []);

      // Fallback: plain endpoint (some servers don't support pagination/filters)
      if (!Array.isArray(tripsRaw) || tripsRaw.length === 0 || tripsRes?.ok === false) {
        const plain = await apiFetch('/api/admin/trips', { suppressError: true });
        const fallbackPayload = plain?.data?.data || plain?.data || {};
        const fallbackRaw = fallbackPayload.trips || fallbackPayload.data || (Array.isArray(fallbackPayload) ? fallbackPayload : []);
        if (Array.isArray(fallbackRaw) && fallbackRaw.length) {
          tripsRaw = fallbackRaw;
          payload = fallbackPayload;
        }
      }

      // Normalize trips
      const normalizedTrips = (tripsRaw || []).map(t => ({
        ...t,
        serviceDate: t.serviceDate ? t.serviceDate.split('T')[0] : '',
        fare: Number(t.fare) || 0,
        capacity: Number(t.capacity) || 0
      }));
      setTrips(normalizedTrips);
      const pagination = payload.pagination || payload.meta || {};
      // Show total from API response, or filtered count if no pagination info
      setTotal(pagination.total || normalizedTrips.length);

      // Fetch lookups in parallel
      const [routesRes, busesRes, driversRes, conductorsRes, depotsRes] = await Promise.all([
        apiFetch('/api/admin/routes', { suppressError: true }),
        apiFetch('/api/admin/buses', { suppressError: true }),
        apiFetch('/api/admin/all-drivers', { suppressError: true }),
        apiFetch('/api/admin/conductors', { suppressError: true }),
        apiFetch('/api/admin/depots?showAll=true', { suppressError: true })
      ]);

      // Normalize routes
      const routesRaw = routesRes?.data?.data?.routes || routesRes?.data?.routes || routesRes?.routes || [];
      const normalizedRoutes = routesRaw.map(r => {
        const sp = r.startingPoint || r.from || {};
        const ep = r.endingPoint || r.to || {};
        const startPlace = typeof sp === 'object' ? (sp.location || sp.city || '') : (sp || '');
        const endPlace = typeof ep === 'object' ? (ep.location || ep.city || '') : (ep || '');
        return {
          ...r,
          routeNumber: r.routeNumber || r.code || '',
          routeName: r.routeName || r.name || '',
          startPlace,
          endPlace
        };
      });

      // Normalize buses
      const busesRaw = busesRes?.data?.data?.buses || busesRes?.data?.buses || busesRes?.buses || [];
      const normalizedBuses = busesRaw.map(b => ({
        ...b,
        busNumber: b.busNumber || 'N/A',
        capacity: b.capacity || { total: 0 }
      }));

      // Normalize drivers
      const driversRaw = driversRes?.data?.data?.drivers || driversRes?.data?.drivers || driversRes?.drivers || [];
      const normalizedDrivers = driversRaw.map(d => ({
        _id: d._id || d.id,
        name: d.name || d.fullName || d.employeeName || 'Driver',
        status: d.status || 'active'
      }));

      // Normalize conductors
      const conductorsRaw = conductorsRes?.data?.data?.conductors || conductorsRes?.data?.conductors || conductorsRes?.conductors || [];
      const normalizedConductors = conductorsRaw.map(c => ({
        _id: c._id || c.id,
        name: c.name || c.fullName || c.employeeName || 'Conductor',
        status: c.status || 'active'
      }));

      // Normalize depots
      const depotsRaw = depotsRes?.data?.data?.depots || depotsRes?.data?.depots || depotsRes?.depots || [];
      const normalizedDepots = depotsRaw.map(d => ({
        _id: d._id || d.id,
        depotName: d.depotName || d.name || 'Depot'
      }));

      setRoutes(normalizedRoutes);
      setBuses(normalizedBuses);
      setDrivers(normalizedDrivers);
      setConductors(normalizedConductors);
      setDepots(normalizedDepots);
    } catch (error) {
      console.error('Error fetching data:', error);
      toast.error('Failed to fetch trip management data');
    } finally {
      setLoading(false);
    }
  }, [page, limit, searchTerm, statusFilter, dateFilter, viewMode]);

  // Fetch live counts from backend using pagination totals per status
  const fetchCounts = useCallback(async () => {
    try {
      // Use the new live trip stats API
      const res = await apiFetch('/api/admin/trip-stats', { suppressError: true });
      if (res?.success && res?.data) {
        const stats = res.data;
        setStatsCounts({ 
          total: stats.total, 
          scheduled: stats.scheduled, 
          running: stats.running, 
          completed: stats.completed 
        });
        setTotal(stats.total);
        console.log('📊 Live trip stats updated:', {
          total: stats.total,
          scheduled: stats.scheduled,
          running: stats.running,
          completed: stats.completed,
          shouldBeRunning: stats.shouldBeRunning,
          actuallyRunning: stats.actuallyRunning
        });
      } else {
        // Fallback to old method if new API fails
        const baseParams = new URLSearchParams();
        // respect date filter when present
        if (dateFilter) {
          const d = new Date(dateFilter);
          const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0).toISOString();
          const end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999).toISOString();
          baseParams.set('dateFrom', start);
          baseParams.set('dateTo', end);
        }

        const mk = async (status) => {
          const p = new URLSearchParams(baseParams);
          p.set('page', '1');
          p.set('limit', '1');
          if (status) p.set('status', status);
          const res = await apiFetch('/api/admin/trips?' + p.toString(), { suppressError: true });
          const data = res?.data || {};
          const total = data?.data?.pagination?.total || data?.pagination?.total || 0;
          return total;
        };

        const [totalAll, totalScheduled, totalRunning, totalCompleted] = await Promise.all([
          mk(null),
          mk('scheduled'),
          mk('running'),
          mk('completed')
        ]);

        setStatsCounts({ total: totalAll, scheduled: totalScheduled, running: totalRunning, completed: totalCompleted });
        setTotal(totalAll);
      }
    } catch (e) {
      console.error('Error fetching trip counts:', e);
      // ignore errors to avoid noisy UI; counts will be updated next cycle
    }
  }, [dateFilter]);

  // Auto-refresh counts periodically after fetchCounts is defined
  useEffect(() => {
    const id = setInterval(() => {
      fetchCounts();
    }, 30000);
    return () => clearInterval(id);
  }, [fetchCounts]);

  // Initialize after functions are defined
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  useEffect(() => {
    fetchCounts();
  }, [fetchCounts]);

  const handleSingleTripAdd = async () => {
    try {
      if (!tripForm.routeId || !tripForm.serviceDate || !tripForm.startTime) {
        toast.error('Route, date, and start time are required');
        return;
      }
      setLoading(true);
      const payload = {
        ...tripForm,
        fare: Number(tripForm.fare) || 0,
        capacity: Number(tripForm.capacity) || 0
      };
      const response = await apiFetch('/api/admin/trips', {
        method: 'POST',
        body: JSON.stringify(payload)
      });

      if (response?.ok || response?.success) {
        toast.success('Trip added successfully');
        setShowSingleAddModal(false);
        resetForm();
        fetchData();
      } else {
        toast.error(response?.message || 'Failed to add trip');
      }
    } catch (error) {
      console.error('Error adding trip:', error);
      toast.error('Failed to add trip');
    } finally {
      setLoading(false);
    }
  };

  const handleUpdateTrip = async () => {
    try {
      if (!selectedTrip?._id) return;
      setLoading(true);

      const isValidObjectId = (v) => typeof v === 'string' && /^[0-9a-fA-F]{24}$/.test(v);
      const clean = { ...tripForm };

      // Normalize optional ObjectId fields
      clean.busId = isValidObjectId(clean.busId) ? clean.busId : undefined;
      clean.driverId = isValidObjectId(clean.driverId) ? clean.driverId : undefined;
      clean.conductorId = isValidObjectId(clean.conductorId) ? clean.conductorId : undefined;
      clean.routeId = isValidObjectId(clean.routeId) ? clean.routeId : undefined;

      // Keep serviceDate as YYYY-MM-DD string (backend parses)
      if (typeof clean.serviceDate === 'string') {
        const m = clean.serviceDate.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        clean.serviceDate = m ? clean.serviceDate : undefined;
      }

      // Coerce time formats HH:MM (strip seconds)
      const toHm = (t) => (typeof t === 'string' && t.length >= 5 ? t.slice(0, 5) : undefined);
      clean.startTime = toHm(clean.startTime);
      clean.endTime = toHm(clean.endTime);

      // Numeric fields
      if (clean.fare !== undefined) clean.fare = Number(clean.fare);
      if (clean.capacity !== undefined) clean.capacity = Number(clean.capacity);

      // Remove empty strings and undefined keys
      const payload = Object.entries(clean).reduce((acc, [k, v]) => {
        if (v !== undefined && v !== '') acc[k] = v;
        return acc;
      }, {});

      const res = await apiFetch(`/api/admin/trips/${selectedTrip._id}`, { method: 'PUT', body: JSON.stringify(payload) });
      if (res?.ok || res?.success) {
        toast.success('Trip updated');
        setShowEditModal(false);
        setSelectedTrip(null);
        fetchData();
      } else {
        toast.error(res?.message || 'Failed to update trip');
      }
    } catch (e) {
      console.error(e);
      toast.error('Failed to update trip');
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteTrip = async (tripId) => {
    try {
      if (!window.confirm('Are you sure you want to delete this trip?')) return;
      setLoading(true);
      const res = await apiFetch(`/api/admin/trips/${tripId}`, { method: 'DELETE' });
      if (res?.ok || res?.success) {
        toast.success('Trip deleted');
      fetchData();
      } else {
        toast.error(res?.message || 'Failed to delete trip');
      }
    } catch (e) {
      console.error(e);
      toast.error('Failed to delete trip');
    } finally {
      setLoading(false);
    }
  };

  const handleGenerate100Trips = async () => {
    try {
      if (!window.confirm('This will clear ALL existing trips and create new trips using available resources. Are you sure?')) {
        return;
      }
      
      setLoading(true);
      toast.loading('Generating trips...', { id: 'generate-trips' });
      
      const response = await apiFetch('/api/trip-generator/generate-100-trips', {
        method: 'POST'
      });
      
      if (response?.success) {
        toast.success(`Successfully generated ${response.data.tripsCreated} trips!`, { id: 'generate-trips' });
        // Refresh the data
        await fetchData();
      } else {
        toast.error(response?.error || 'Failed to generate trips', { id: 'generate-trips' });
      }
    } catch (error) {
      console.error('Error generating trips:', error);
      toast.error('Failed to generate trips', { id: 'generate-trips' });
    } finally {
      setLoading(false);
    }
  };

  const handleScheduleToYearEnd = async () => {
    try {
      setLoading(true);
      const now = new Date();
      const startDate = (dateFilter && /^\d{4}-\d{2}-\d{2}$/.test(dateFilter)) ? dateFilter : new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString().slice(0,10);
      const endDate = new Date(now.getFullYear(), 11, 31).toISOString().slice(0,10);
      toast.loading(`Scheduling all routes from ${startDate} to ${endDate}...`, { id: 'year-end' });
      const res = await apiFetch('/api/auto-scheduler/schedule-all', {
        method: 'POST',
        body: JSON.stringify({ startDate, endDate, options: { autoAssignCrew: true, autoAssignBuses: true } })
      });
      if (res?.ok || res?.success) {
        toast.success('Scheduled through year end successfully', { id: 'year-end' });
        fetchCounts();
      } else {
        toast.error(res?.message || 'Year-end scheduling failed', { id: 'year-end' });
      }
    } catch (e) {
      console.error('Year-end scheduling error', e);
      toast.error('Year-end scheduling failed', { id: 'year-end' });
    } finally {
      setLoading(false);
    }
  };

  const handleExportTrips = async () => {
    try {
      const rows = filteredTrips.map(t => {
        const route = routes.find(r => r._id === t.routeId);
        const bus = buses.find(b => b._id === t.busId);
        const driver = drivers.find(d => d._id === t.driverId);
        const conductor = conductors.find(c => c._id === t.conductorId);
        return {
          tripId: t._id,
          routeNumber: route?.routeNumber || '',
          routeName: route?.routeName || '',
          busNumber: bus?.busNumber || '',
          driverName: driver?.name || '',
          conductorName: conductor?.name || '',
          serviceDate: t.serviceDate,
          startTime: t.startTime,
          endTime: t.endTime,
          fare: t.fare,
          capacity: t.capacity,
          status: t.status
        };
      });
      const header = Object.keys(rows[0] || { tripId: '', routeNumber: '', routeName: '', busNumber: '', driverName: '', conductorName: '', serviceDate: '', startTime: '', endTime: '', fare: '', capacity: '', status: '' });
      const csv = [header.join(','), ...rows.map(r => header.map(h => String(r[h] ?? '').replace(/"/g, '""')).map(v => v.includes(',') ? `"${v}"` : v).join(','))].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'trips.csv';
      a.click();
      URL.revokeObjectURL(url);
      toast.success('Trips exported to CSV');
    } catch (e) {
      console.error(e);
      toast.error('Export failed');
    }
  };

  const handleGenerate4PerDepot = async () => {
    try {
      const today = new Date().toISOString().slice(0,10);
      setLoading(true);
      toast.loading('Creating 4 trips per depot...', { id: 'gen-4pd' });
      const res = await apiFetch('/api/trip-generator/generate-4-per-depot', {
        method: 'POST',
        body: JSON.stringify({ date: dateFilter || today })
      });
      if (res?.success || res?.ok) {
        const created = res?.data?.trips || [];
        if (Array.isArray(created) && created.length) {
          // Optimistic UI: prepend created trips instantly
          setTrips(prev => {
            const normalized = created.map(t => ({
              ...t,
              serviceDate: t.serviceDate ? String(t.serviceDate).split('T')[0] : '',
              fare: Number(t.fare) || 0,
              capacity: Number(t.capacity) || 0
            }));
            return [...normalized, ...prev];
          });
        }
        toast.success(res?.message || 'Trips created', { id: 'gen-4pd' });
        // Background refresh to hydrate with populated fields
        fetchData();
      } else {
        toast.error(res?.message || res?.error || 'Failed to create trips', { id: 'gen-4pd' });
      }
    } catch (e) {
      console.error('Generate 4 per depot failed', e);
      toast.error('Failed to create trips', { id: 'gen-4pd' });
    } finally {
      setLoading(false);
    }
  };

  // Removed bulk trip add function - simplified for core CRUD focus

  const handleAutoScheduling = async () => {
    try {
      if (!schedulerForm.targetDate) {
        toast.error('Please select a target date');
        return;
      }

      setLoading(true);
      console.log('Starting auto scheduling with form:', schedulerForm);
      
      const response = await apiFetch('/api/auto-scheduler/mass-schedule', {
        method: 'POST',
        body: JSON.stringify({
          date: schedulerForm.targetDate,
          depotIds: schedulerForm.depotIds,
          maxTripsPerRoute: schedulerForm.maxTripsPerRoute,
          timeGap: schedulerForm.timeGap,
          autoAssignCrew: schedulerForm.autoAssignCrew,
          autoAssignBuses: schedulerForm.autoAssignBuses,
          generateReports: schedulerForm.generateReports
        })
      });

      console.log('Auto scheduling response:', response);

      if (response?.success || response?.ok) {
        const tripsCreated = response.data?.tripsCreated || response.tripsCreated || 0;
        const successRate = response.data?.successRate || response.successRate || '0%';
        
        toast.success(`Auto-scheduling completed! ${tripsCreated} trips created (${successRate} success rate)`);
        setShowAutoSchedulerModal(false);
        resetSchedulerForm();
        fetchData();
      } else {
        const errorMessage = response?.message || response?.error || 'Auto scheduling failed';
        toast.error(errorMessage);
        console.error('Auto scheduling failed:', response);
      }
    } catch (error) {
      console.error('Error in auto scheduling:', error);
      toast.error(`Auto scheduling failed: ${error.message || 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  // Removed batch operation function - simplified for core CRUD focus

  // Helper functions
  // const calculateEndTime = (startTime, durationMinutes) => {
  //   if (!startTime || !durationMinutes) return '';
  //   const [hours, minutes] = startTime.split(':').map(Number);
  //   const totalMinutes = hours * 60 + minutes + durationMinutes;
  //   const endHours = Math.floor(totalMinutes / 60) % 24;
  //   const endMinutes = totalMinutes % 60;
  //   return `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;
  // };

  // Enhanced Route Generation Functions
  const geocodeLocation = async (locationName) => {
    try {
      // Use Google Maps Geocoding API
      if (window.google && window.google.maps) {
        const geocoder = new window.google.maps.Geocoder();
        
        return new Promise((resolve) => {
          geocoder.geocode({ address: locationName, region: 'IN' }, (results, status) => {
            if (status === 'OK' && results[0]) {
              const result = results[0];
              const location = result.geometry.location;
              resolve({
                lat: location.lat(),
                lng: location.lng(),
                display_name: result.formatted_address
              });
            } else {
              resolve(null);
            }
          });
        });
      } else {
        // Fallback to OpenStreetMap Nominatim when Google Maps is unavailable
        try {
          const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationName)}&addressdetails=1&limit=1`);
          const data = await resp.json();
          if (Array.isArray(data) && data.length > 0) {
            return {
              lat: parseFloat(data[0].lat),
              lng: parseFloat(data[0].lon),
              display_name: data[0].display_name
            };
          }
        } catch {}
        return null;
      }
    } catch (error) {
      console.error('Geocoding error:', error);
      return null;
    }
  };

  const generateRoute = async (startCoords, endCoords) => {
    try {
      const response = await fetch(
        `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=polyline`
      );
      const data = await response.json();
      
      if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
        const route = data.routes[0];
        return {
          polyline: route.geometry,
          distance: route.distance / 1000, // Convert to km
          duration: route.duration / 60 // Convert to minutes
        };
      }
      return null;
    } catch (error) {
      console.error('Route generation error:', error);
      return null;
    }
  };

  const extractStopsFromRoute = useCallback(async (polyline, startLocation, endLocation) => {
    try {
      // Decode polyline to get coordinates
      const coordinates = decodePolyline(polyline);
      const stops = [];
      
      // Add start location
      stops.push({
        stopName: startLocation,
        city: startLocation.split(',')[0],
        location: startLocation,
        stopNumber: 1,
        distanceFromPrev: 0,
        distanceFromStart: 0,
        coordinates: { latitude: coordinates[0].lat, longitude: coordinates[0].lng },
        isActive: true
      });

      // Sample points along the route for intermediate stops
      const sampleInterval = Math.max(1, Math.floor(coordinates.length / 8)); // Get ~8 intermediate stops
      
      for (let i = sampleInterval; i < coordinates.length - sampleInterval; i += sampleInterval) {
        const coord = coordinates[i];
        
        // Use reverse geocoding to get place name
        const placeInfo = await reverseGeocode(coord.lat, coord.lng);
        
        if (placeInfo) {
          const distanceFromStart = calculateDistance(
            coordinates[0].lat, coordinates[0].lng,
            coord.lat, coord.lng
          );
          
          stops.push({
            stopName: placeInfo.name,
            city: placeInfo.city || placeInfo.name,
            location: placeInfo.display_name,
            stopNumber: stops.length + 1,
            distanceFromPrev: stops.length > 0 ? 
              calculateDistance(
                stops[stops.length - 1].coordinates.latitude,
                stops[stops.length - 1].coordinates.longitude,
                coord.lat, coord.lng
              ) : 0,
            distanceFromStart: distanceFromStart,
            coordinates: { latitude: coord.lat, longitude: coord.lng },
            isActive: true
          });
        }
      }

      // Add end location
      const endCoord = coordinates[coordinates.length - 1];
      const endDistance = calculateDistance(
        coordinates[0].lat, coordinates[0].lng,
        endCoord.lat, endCoord.lng
      );
      
      stops.push({
        stopName: endLocation,
        city: endLocation.split(',')[0],
        location: endLocation,
        stopNumber: stops.length + 1,
        distanceFromPrev: stops.length > 0 ? 
          calculateDistance(
            stops[stops.length - 1].coordinates.latitude,
            stops[stops.length - 1].coordinates.longitude,
            endCoord.lat, endCoord.lng
          ) : 0,
        distanceFromStart: endDistance,
        coordinates: { latitude: endCoord.lat, longitude: endCoord.lng },
        isActive: true
      });

      return stops;
    } catch (error) {
      console.error('Stop extraction error:', error);
      return [];
    }
  }, [decodePolyline, calculateDistance, reverseGeocode]);


  const handleRouteGeneration = useCallback(async () => {
    if (!routeBuilderForm.startLocation || !routeBuilderForm.endLocation) {
      toast.error('Please enter both start and end locations');
      return;
    }

    setIsGeneratingRoute(true);
    try {
      // Step 1: Geocode locations
      toast('Finding locations...');
      const [startCoords, endCoords] = await Promise.all([
        geocodeLocation(routeBuilderForm.startLocation),
        geocodeLocation(routeBuilderForm.endLocation)
      ]);

      if (!startCoords || !endCoords) {
        toast.error('Could not find one or both locations. Please try different location names.');
        return;
      }

      // Step 2: Generate route
      toast('Generating optimal route...');
      const routeData = await generateRoute(startCoords, endCoords);
      
      if (!routeData) {
        toast.error('Could not generate route between these locations.');
        return;
      }

      // Step 3: Extract stops
      toast('Extracting intermediate stops...');
      const stops = await extractStopsFromRoute(
        routeData.polyline,
        routeBuilderForm.startLocation,
        routeBuilderForm.endLocation
      );

      // Update form with generated data
      setRouteBuilderForm(prev => ({
        ...prev,
        startCoords,
        endCoords,
        routePolyline: routeData.polyline,
        autoGeneratedStops: stops,
        totalDistance: routeData.distance,
        estimatedDuration: routeData.duration,
        routeName: `${routeBuilderForm.startLocation} → ${routeBuilderForm.endLocation}`
      }));

      toast.success(`Route generated successfully! Found ${stops.length} stops over ${routeData.distance.toFixed(1)} km`);
      
    } catch (error) {
      console.error('Route generation error:', error);
      toast.error('Failed to generate route. Please try again.');
    } finally {
      setIsGeneratingRoute(false);
    }
  }, [routeBuilderForm.startLocation, routeBuilderForm.endLocation, extractStopsFromRoute]);

  const saveGeneratedRoute = useCallback(async () => {
    if (!routeBuilderForm.routeNumber || !routeBuilderForm.depotId) {
      toast.error('Please enter route number and select depot');
      return;
    }

    setLoading(true);
    try {
      const routeData = {
        routeNumber: routeBuilderForm.routeNumber,
        routeName: routeBuilderForm.routeName,
        startingPoint: {
          city: routeBuilderForm.startLocation.split(',')[0],
          location: routeBuilderForm.startLocation,
          coordinates: {
            latitude: routeBuilderForm.startCoords.lat,
            longitude: routeBuilderForm.startCoords.lng
          }
        },
        endingPoint: {
          city: routeBuilderForm.endLocation.split(',')[0],
          location: routeBuilderForm.endLocation,
          coordinates: {
            latitude: routeBuilderForm.endCoords.lat,
            longitude: routeBuilderForm.endCoords.lng
          }
        },
        totalDistance: routeBuilderForm.totalDistance,
        estimatedDuration: routeBuilderForm.estimatedDuration,
        stops: routeBuilderForm.autoGeneratedStops,
        depotId: routeBuilderForm.depotId,
        baseFare: routeBuilderForm.totalDistance * routeBuilderForm.farePerKm,
        farePerKm: routeBuilderForm.farePerKm,
        status: 'active',
        routePolyline: routeBuilderForm.routePolyline,
        busType: routeBuilderForm.busType
      };

      const response = await apiFetch('/api/admin/routes', {
        method: 'POST',
        body: JSON.stringify(routeData)
      });

      if (response.success) {
        toast.success('Route saved successfully!');
        setShowRouteBuilder(false);
        resetRouteBuilderForm();
        fetchData();
      } else {
        toast.error(response.message || 'Failed to save route');
      }
    } catch (error) {
      console.error('Error saving route:', error);
      toast.error('Failed to save route');
    } finally {
      setLoading(false);
    }
  }, [routeBuilderForm, fetchData]);

  const resetRouteBuilderForm = () => {
    setRouteBuilderForm({
      routeNumber: '',
      routeName: '',
      startLocation: '',
      endLocation: '',
      startCoords: null,
      endCoords: null,
      depotId: '',
      busType: 'standard',
      farePerKm: 2.5,
      routePolyline: null,
      autoGeneratedStops: [],
      totalDistance: 0,
      estimatedDuration: 0
    });
  };

  const resetForm = () => {
    setTripForm({
      routeId: '',
      busId: '',
      driverId: '',
      conductorId: '',
      serviceDate: '',
      startTime: '',
      endTime: '',
      fare: 0,
      capacity: 0,
      status: 'scheduled',
      depotId: '',
      notes: '',
      bookingOpen: true,
      bookingCloseTime: '',
      cancellationPolicy: {
        hoursBeforeDeparture: 2,
        refundPercentage: 80
      }
    });
  };

  // Removed resetBulkForm - not needed for simplified CRUD

  const resetSchedulerForm = () => {
    setSchedulerForm({
      targetDate: new Date().toISOString().slice(0, 10), // Default to today
      depotIds: [],
      maxTripsPerRoute: 5,
      timeGap: 30,
      autoAssignCrew: true,
      autoAssignBuses: true,
      generateReports: true
    });
  };

  const openAssignModal = (mode, preset = {}) => {
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth() + 1).padStart(2, '0');
    const dd = String(now.getDate()).padStart(2, '0');
    const hh = String(now.getHours()).padStart(2, '0');
    const mi = String(now.getMinutes()).padStart(2, '0');
    setAssignMode(mode);
    setAssignForm({
      tripId: preset._id || '',
      routeId: (preset.routeId && (preset.routeId._id || preset.routeId)) || '',
      busId: (preset.busId && (preset.busId._id || preset.busId)) || '',
      driverId: (preset.driverId && (preset.driverId._id || preset.driverId)) || '',
      scheduledDate: mode === 'now' ? `${yyyy}-${mm}-${dd}` : '',
      scheduledTime: mode === 'now' ? `${hh}:${mi}` : ''
    });
    setShowAssignModal(true);
  };

  const handleAssignSubmit = async () => {
    try {
      if (!assignForm.routeId || !assignForm.busId || !assignForm.driverId) {
        toast.error('Route, bus and driver are required');
        return;
      }
      if (!assignForm.scheduledDate || !assignForm.scheduledTime) {
        toast.error('Please select date and time');
        return;
      }
      setLoading(true);
      const res = await apiFetch('/api/admin/assign-trip', {
        method: 'POST',
        body: JSON.stringify({
          driverId: assignForm.driverId,
          routeId: assignForm.routeId,
          busId: assignForm.busId,
          tripId: assignForm.tripId || undefined,
          scheduledDate: assignForm.scheduledDate,
          scheduledTime: assignForm.scheduledTime
        })
      });
      if (res?.ok || res?.success) {
        toast.success('Assignment saved');
        setShowAssignModal(false);
        fetchData();
      } else {
        toast.error(res?.message || 'Failed to assign');
      }
    } catch (e) {
      console.error(e);
      toast.error('Failed to assign');
    } finally {
      setLoading(false);
    }
  };

  const openEditModal = (trip) => {
    setSelectedTrip(trip);
    setTripForm({
      ...trip,
      serviceDate: trip.serviceDate ? trip.serviceDate.split('T')[0] : '',
      bookingCloseTime: trip.bookingCloseTime ? trip.bookingCloseTime.split('T')[0] : ''
    });
    setShowEditModal(true);
  };

  const filteredTrips = trips.filter(trip => {
    const matchesSearch = trip.routeId ? 
      (routes.find(r => r._id === trip.routeId)?.routeNumber || '').toLowerCase().includes(searchTerm.toLowerCase()) ||
      (routes.find(r => r._id === trip.routeId)?.routeName || '').toLowerCase().includes(searchTerm.toLowerCase()) : false;
    const matchesStatus = statusFilter === 'all' || trip.status === statusFilter;
    const matchesDate = !dateFilter || trip.serviceDate === dateFilter;
    const matchesRoute = routeFilter === 'all' || trip.routeId === routeFilter;
    
    return matchesSearch && matchesStatus && matchesDate && matchesRoute;
  });

  const getStatusColor = (status) => {
    switch (status) {
      case 'scheduled': return 'bg-blue-100 text-blue-800';
      case 'boarding': return 'bg-yellow-100 text-yellow-800';
      case 'running': return 'bg-green-100 text-green-800';
      case 'completed': return 'bg-gray-100 text-gray-800';
      case 'cancelled': return 'bg-red-100 text-red-800';
      case 'delayed': return 'bg-orange-100 text-orange-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const TripCard = ({ trip }) => {
    // Helpers to resolve id or object
    const resolveId = (val) => (val && typeof val === 'object' ? (val._id || val.id) : val);
    const findById = (list, id) => list.find((x) => resolveId(x._id || x.id) === resolveId(id));

    const routeObj = (trip.routeId && typeof trip.routeId === 'object')
      ? trip.routeId
      : findById(routes, trip.routeId);

    const busObj = (trip.busId && typeof trip.busId === 'object')
      ? trip.busId
      : findById(buses, trip.busId);

    const driverObj = (trip.driverId && typeof trip.driverId === 'object')
      ? trip.driverId
      : findById(drivers, trip.driverId);

    const conductorObj = (trip.conductorId && typeof trip.conductorId === 'object')
      ? trip.conductorId
      : findById(conductors, trip.conductorId);

    // Resolve depot: prefer trip.depotId, else route.depotId
    let depotObj = null;
    if (trip.depotId) {
      depotObj = (typeof trip.depotId === 'object') ? trip.depotId : findById(depots, trip.depotId);
    }
    if (!depotObj && routeObj) {
      const routeDepotId = routeObj.depotId || routeObj.depot;
      if (routeDepotId) {
        depotObj = (typeof routeDepotId === 'object') ? routeDepotId : findById(depots, routeDepotId);
      }
    }

    const routeNumber = trip.routeNumber || routeObj?.routeNumber || routeObj?.code || 'N/A';
    const routeName = trip.routeName || routeObj?.routeName || routeObj?.name || 'Unknown Route';

    const busLabel = busObj?.busNumber || 'Unassigned';
    const driverLabel = driverObj?.name || 'No Driver';
    const conductorLabel = conductorObj?.name || 'No Conductor';
    const depotLabel = depotObj?.depotName || depotObj?.name || '';
    
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 hover:shadow-md transition-shadow"
      >
        <div className="flex items-center justify-between mb-1">
          {depotLabel ? (
            <span className="px-2 py-0.5 text-xs bg-gray-100 text-gray-700 rounded">{depotLabel}</span>
          ) : <span />}
        </div>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center space-x-3">
            <input
              type="checkbox"
              checked={selectedTrips.includes(trip._id)}
              onChange={(e) => {
                if (e.target.checked) {
                  setSelectedTrips([...selectedTrips, trip._id]);
                } else {
                  setSelectedTrips(selectedTrips.filter(id => id !== trip._id));
                }
              }}
              className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
            />
            <div className="p-2 bg-blue-100 rounded-lg">
              <Calendar className="w-5 h-5 text-blue-600" />
            </div>
            <div>
              <h3 className="font-semibold text-gray-900">{routeNumber}</h3>
              <p className="text-sm text-gray-500">{routeName}</p>
              <p className="text-xs text-gray-500">
                {(routes.find(r=> (r._id||r.id) === (routeObj?._id||routeObj?.id))?.startPlace || routeObj?.startingPoint?.location || routeObj?.startingPoint?.city || '')}
                {" 														"}
                →
                {" "}
                {(routes.find(r=> (r._id||r.id) === (routeObj?._id||routeObj?.id))?.endPlace || routeObj?.endingPoint?.location || routeObj?.endingPoint?.city || '')}
              </p>
            </div>
          </div>
          <span className={`px-3 py-1 rounded-full text-xs font-medium ${getStatusColor(trip.status)}`}>
            {trip.status}
          </span>
        </div>

        <div className="space-y-3 mb-4">
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <Clock className="w-4 h-4" />
            <span>{trip.startTime} - {trip.endTime}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <Calendar className="w-4 h-4" />
            <span>{new Date(trip.serviceDate).toLocaleDateString()}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <Bus className="w-4 h-4" />
            <span>{busLabel} • {trip.capacity} seats</span>
          </div>
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <Users className="w-4 h-4" />
            <span>{driverLabel} • {conductorLabel}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <DollarSign className="w-4 h-4" />
            <span>₹{trip.fare} • {trip.bookedSeats || 0}/{trip.capacity} booked</span>
          </div>
        </div>

        <div className="flex items-center justify-between pt-4 border-t border-gray-100">
          <div className="flex space-x-2">
            <button
              onClick={() => openEditModal(trip)}
              className="p-2 text-blue-600 hover:bg-blue-50 rounded-lg transition-colors"
              title="Edit Trip"
            >
              <Edit className="w-4 h-4" />
            </button>
            <button
              onClick={() => handleDeleteTrip(trip._id)}
              className="p-2 text-red-600 hover:bg-red-50 rounded-lg transition-colors"
              title="Delete Trip"
            >
              <Trash2 className="w-4 h-4" />
            </button>
            <button
              onClick={() => {/* View details */}}
              className="p-2 text-green-600 hover:bg-green-50 rounded-lg transition-colors"
              title="View Details"
            >
              <Eye className="w-4 h-4" />
            </button>
            <button
              onClick={() => openAssignModal('now', trip)}
              className="p-2 text-purple-600 hover:bg-purple-50 rounded-lg transition-colors"
              title="Assign Now"
            >
              <UserCheck className="w-4 h-4" />
            </button>
            <button
              onClick={() => openAssignModal('date', trip)}
              className="p-2 text-gray-700 hover:bg-gray-50 rounded-lg transition-colors"
              title="Assign for Date"
            >
              <CalendarDays className="w-4 h-4" />
            </button>
          </div>
          <div className="text-xs text-gray-500">
            {trip.bookingOpen ? 'Booking Open' : 'Booking Closed'}
          </div>
        </div>
      </motion.div>
    );
  };


  // Individual input handlers for better performance with debouncing
  const handleStartLocationChange = useCallback((e) => {
    const value = e.target.value;
    setRouteBuilderForm(prev => ({
      ...prev,
      startLocation: value
    }));
  }, []);

  const handleEndLocationChange = useCallback((e) => {
    const value = e.target.value;
    setRouteBuilderForm(prev => ({
      ...prev,
      endLocation: value
    }));
  }, []);

  const handleRouteNumberChange = useCallback((e) => {
    const value = e.target.value;
    setRouteBuilderForm(prev => ({
      ...prev,
      routeNumber: value
    }));
  }, []);

  const handleDepotChange = useCallback((e) => {
    const value = e.target.value;
    setRouteBuilderForm(prev => ({
      ...prev,
      depotId: value
    }));
  }, []);

  const handleBusTypeChange = useCallback((e) => {
    const value = e.target.value;
    setRouteBuilderForm(prev => ({
      ...prev,
      busType: value
    }));
  }, []);

  const handleFareChange = useCallback((e) => {
    const value = parseFloat(e.target.value) || 0;
    setRouteBuilderForm(prev => ({
      ...prev,
      farePerKm: value
    }));
  }, []);

  const RouteBuilderModal = React.memo(() => {
    if (!showRouteBuilder) return null;

    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
        onClick={() => setShowRouteBuilder(false)}
      >
        <motion.div
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          className="bg-white rounded-xl shadow-xl max-w-4xl w-full mx-4 max-h-[85vh] overflow-y-auto"
          onClick={(e) => e.stopPropagation()}
        >
            <div className="p-6 border-b border-gray-200 bg-gradient-to-r from-purple-50 to-blue-50">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-2xl font-bold text-gray-900 flex items-center space-x-2">
                    <div className="p-1.5 bg-purple-100 rounded-lg">
                      <Route className="w-6 h-6 text-purple-600" />
                    </div>
                    <span>Smart Route Builder</span>
                  </h3>
                  <p className="text-sm text-gray-600 mt-1">
                    Automated route generation with automatic stop extraction and fare calculation
                  </p>
                </div>
                <button
                  onClick={() => setShowRouteBuilder(false)}
                  className="text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full p-2 transition-colors"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>
            
            <div className="p-6 space-y-6">
              {/* Route Configuration */}
              <div className="bg-gradient-to-br from-purple-50 to-blue-50 rounded-lg p-6 border border-purple-200">
                <h4 className="text-xl font-bold text-purple-900 mb-4 flex items-center">
                  <div className="p-1.5 bg-purple-100 rounded-lg mr-2">
                    <Zap className="w-5 h-5 text-purple-600" />
                  </div>
                  Route Configuration
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Start Location *
                    </label>
                    <input
                      type="text"
                      value={routeBuilderForm.startLocation || ''}
                      onChange={handleStartLocationChange}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter' && routeBuilderForm.startLocation && routeBuilderForm.endLocation) {
                          e.preventDefault();
                          handleRouteGeneration();
                        }
                      }}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-blue-50"
                      placeholder="Enter start location"
                      title="Enter the starting location for your route"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      End Location *
                    </label>
                    <input
                      type="text"
                      value={routeBuilderForm.endLocation || ''}
                      onChange={handleEndLocationChange}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter' && routeBuilderForm.startLocation && routeBuilderForm.endLocation) {
                          e.preventDefault();
                          handleRouteGeneration();
                        }
                      }}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-blue-50"
                      placeholder="Enter end location"
                      title="Enter the destination location for your route"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Route Number *
                    </label>
                    <input
                      type="text"
                      value={routeBuilderForm.routeNumber || ''}
                      onChange={handleRouteNumberChange}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-blue-50"
                      placeholder="Enter route number"
                      title="Enter a unique route number"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Depot *
                    </label>
                    <select
                      value={routeBuilderForm.depotId || ''}
                      onChange={handleDepotChange}
                      disabled={!depots || depots.length === 0}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-blue-50 disabled:opacity-60"
                      title="Select the depot for this route"
                    >
                      <option value="">Select Depot</option>
                      {depots.map(depot => (
                        <option key={depot._id} value={depot._id}>{depot.depotName}</option>
                      ))}
                    </select>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Bus Type
                    </label>
                    <select
                      value={routeBuilderForm.busType || 'standard'}
                      onChange={handleBusTypeChange}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-blue-50"
                      title="Select the bus type for this route"
                    >
                      <option value="standard">Standard</option>
                      <option value="deluxe">Deluxe</option>
                      <option value="ac">AC</option>
                      <option value="sleeper">Sleeper</option>
                    </select>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Fare per KM (₹)
                    </label>
                    <input
                      type="number"
                      step="0.1"
                      min="0"
                      value={routeBuilderForm.farePerKm || 2.5}
                      onChange={handleFareChange}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-blue-50"
                      placeholder="2.5"
                      title="Enter fare per kilometer"
                    />
                  </div>
                </div>
                
                <div className="mt-6 text-center space-y-4">
                  <button
                    onClick={handleRouteGeneration}
                    disabled={isGeneratingRoute || !routeBuilderForm.startLocation || !routeBuilderForm.endLocation}
                    className="px-8 py-3 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 flex items-center space-x-2 mx-auto"
                  >
                    {isGeneratingRoute ? (
                      <RefreshCw className="w-4 h-4 animate-spin" />
                    ) : (
                      <Zap className="w-4 h-4" />
                    )}
                    <span>{isGeneratingRoute ? 'Generating Route...' : 'Generate Route & Extract Stops'}</span>
                  </button>
                  
                  <div className="text-sm text-gray-600">
                    <p>✨ <strong>Ready to create routes!</strong> Fill in the details above.</p>
                    <p>Click "Generate Route" to create your route with automatic stop extraction.</p>
                  </div>
                </div>
              </div>

              {/* Route Results */}
              {routeBuilderForm.autoGeneratedStops.length > 0 && (
                <div className="bg-gradient-to-br from-green-50 to-emerald-50 rounded-lg p-6 border border-green-200">
                  <h4 className="text-xl font-bold text-green-900 mb-4 flex items-center">
                    <div className="p-1.5 bg-green-100 rounded-lg mr-2">
                      <Navigation className="w-5 h-5 text-green-600" />
                    </div>
                    Generated Route Details
                  </h4>
                  
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div className="bg-white rounded-lg p-4 border border-green-200">
                      <div className="text-sm font-medium text-gray-700 mb-1">Total Distance</div>
                      <div className="text-2xl font-bold text-green-600">
                        {routeBuilderForm.totalDistance.toFixed(1)} km
                      </div>
                    </div>
                    <div className="bg-white rounded-lg p-4 border border-green-200">
                      <div className="text-sm font-medium text-gray-700 mb-1">Estimated Duration</div>
                      <div className="text-2xl font-bold text-green-600">
                        {Math.floor(routeBuilderForm.estimatedDuration / 60)}h {routeBuilderForm.estimatedDuration % 60}m
                      </div>
                    </div>
                    <div className="bg-white rounded-lg p-4 border border-green-200">
                      <div className="text-sm font-medium text-gray-700 mb-1">Total Fare</div>
                      <div className="text-2xl font-bold text-green-600">
                        ₹{(routeBuilderForm.totalDistance * routeBuilderForm.farePerKm).toFixed(0)}
                      </div>
                    </div>
                  </div>

                  {/* Auto-generated Stops */}
                  <div className="bg-white rounded-lg p-4 border border-green-200">
                    <h5 className="text-lg font-bold text-gray-800 mb-4 flex items-center">
                      <div className="p-1.5 bg-green-100 rounded-lg mr-2">
                        <MapPin className="w-4 h-4 text-green-600" />
                      </div>
                      Auto-Generated Stops ({routeBuilderForm.autoGeneratedStops.length})
                    </h5>
                    
                    <div className="space-y-2 max-h-60 overflow-y-auto">
                      {routeBuilderForm.autoGeneratedStops.map((stop, index) => (
                        <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg border border-gray-200">
                          <div className="flex items-center space-x-3">
                            <div className="w-6 h-6 bg-purple-100 text-purple-600 rounded-full flex items-center justify-center text-xs font-bold">
                              {stop.stopNumber}
                            </div>
                            <div>
                              <div className="font-medium text-gray-900">{stop.stopName}</div>
                              <div className="text-sm text-gray-600">{stop.city}</div>
                            </div>
                          </div>
                          <div className="text-right">
                            <div className="font-medium text-gray-900">
                              {stop.distanceFromStart.toFixed(1)} km
                            </div>
                            <div className="text-sm text-green-600 font-semibold">
                              ₹{(stop.distanceFromStart * routeBuilderForm.farePerKm).toFixed(0)}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}
              
              <div className="flex items-center justify-end space-x-4 pt-6 border-t border-gray-200">
                <button
                  onClick={() => setShowRouteBuilder(false)}
                  className="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={saveGeneratedRoute}
                  disabled={loading || !routeBuilderForm.routeNumber || !routeBuilderForm.depotId || routeBuilderForm.autoGeneratedStops.length === 0}
                  className="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 flex items-center space-x-2"
                >
                  {loading ? <RefreshCw className="w-4 h-4 animate-spin" /> : <Save className="w-4 h-4" />}
                  <span>Save Route</span>
                </button>
              </div>
            </div>
          </motion.div>
        </motion.div>
    );
  });

  const AutoSchedulerModal = () => (
    <AnimatePresence>
      {showAutoSchedulerModal && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
          onClick={() => setShowAutoSchedulerModal(false)}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
            className="bg-white rounded-xl shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="p-6 border-b border-gray-200">
              <div className="flex items-center justify-between">
                <h3 className="text-xl font-semibold text-gray-900 flex items-center space-x-2">
                  <Sparkles className="w-6 h-6 text-purple-600" />
                  <span>Auto Scheduler</span>
                </h3>
                <button
                  onClick={() => setShowAutoSchedulerModal(false)}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>
            
            <div className="p-6 space-y-6">
              <div className="bg-purple-50 rounded-lg p-4">
                <h4 className="font-semibold text-purple-800 mb-2">🚀 Automated Scheduling</h4>
                <p className="text-purple-700 text-sm">
                  This will automatically schedule trips for all buses, assign optimal routes, 
                  and allocate drivers/conductors based on demand patterns and efficiency algorithms.
                </p>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Target Date *
                  </label>
                  <input
                    type="date"
                    value={schedulerForm.targetDate}
                    onChange={(e) => setSchedulerForm(prev => ({ ...prev, targetDate: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Max Trips per Route
                  </label>
                  <input
                    type="number"
                    min="1"
                    max="20"
                    value={schedulerForm.maxTripsPerRoute}
                    onChange={(e) => setSchedulerForm(prev => ({ ...prev, maxTripsPerRoute: parseInt(e.target.value) }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Time Gap (minutes)
                  </label>
                  <input
                    type="number"
                    min="15"
                    max="120"
                    value={schedulerForm.timeGap}
                    onChange={(e) => setSchedulerForm(prev => ({ ...prev, timeGap: parseInt(e.target.value) }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Depots
                  </label>
                  <select
                    multiple
                    value={schedulerForm.depotIds}
                    onChange={(e) => setSchedulerForm(prev => ({ 
                      ...prev, 
                      depotIds: Array.from(e.target.selectedOptions, option => option.value)
                    }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  >
                    {depots.map(depot => (
                      <option key={depot._id} value={depot._id}>{depot.depotName}</option>
                    ))}
                  </select>
                </div>
              </div>
              
              <div className="space-y-3">
                <label className="flex items-center space-x-3">
                  <input
                    type="checkbox"
                    checked={schedulerForm.autoAssignCrew}
                    onChange={(e) => setSchedulerForm(prev => ({ ...prev, autoAssignCrew: e.target.checked }))}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                  />
                  <span className="text-sm font-medium text-gray-700">Auto-assign drivers and conductors</span>
                </label>
                
                <label className="flex items-center space-x-3">
                  <input
                    type="checkbox"
                    checked={schedulerForm.autoAssignBuses}
                    onChange={(e) => setSchedulerForm(prev => ({ ...prev, autoAssignBuses: e.target.checked }))}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                  />
                  <span className="text-sm font-medium text-gray-700">Auto-assign buses to routes</span>
                </label>
                
                
                <label className="flex items-center space-x-3">
                  <input
                    type="checkbox"
                    checked={schedulerForm.generateReports}
                    onChange={(e) => setSchedulerForm(prev => ({ ...prev, generateReports: e.target.checked }))}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                  />
                  <span className="text-sm font-medium text-gray-700">Generate scheduling reports</span>
                </label>
              </div>
              
              <div className="flex items-center justify-end space-x-4">
                <button
                  onClick={() => setShowAutoSchedulerModal(false)}
                  className="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleAutoScheduling}
                  disabled={loading || !schedulerForm.targetDate}
                  className="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 flex items-center space-x-2"
                >
                  {loading ? <RefreshCw className="w-4 h-4 animate-spin" /> : <Sparkles className="w-4 h-4" />}
                  <span>Start Auto Scheduling</span>
                </button>
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );


  const startTripsForDate = async (targetDateStr) => {
    try {
      setLoading(true);
      const d = targetDateStr ? new Date(targetDateStr) : new Date();
      const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0).toISOString();
      const end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999).toISOString();

      const params = new URLSearchParams();
      params.set('page', '1');
      params.set('limit', '1000');
      params.set('status', 'scheduled');
      params.set('dateFrom', start);
      params.set('dateTo', end);
      const res = await apiFetch('/api/admin/trips?' + params.toString(), { suppressError: true });
      const payload = res?.data?.data || res?.data || {};
      const tripsRaw = payload.trips || payload.data || [];
      const tripIds = (tripsRaw || []).map(t => t._id || t.id).filter(Boolean);

      if (!Array.isArray(tripIds) || tripIds.length === 0) {
        toast('No scheduled trips found for the selected date');
        return;
      }

      let success = 0;
      let fail = 0;
      const ids = [...tripIds];
      const concurrency = 10;
      const runBatch = async () => {
        const batch = ids.splice(0, concurrency);
        await Promise.all(batch.map(async (id) => {
          const r = await apiFetch(`/api/admin/trips/${id}`, { method: 'PUT', body: JSON.stringify({ status: 'running' }) });
          if (r?.ok || r?.success) success++; else fail++;
        }));
      };
      while (ids.length > 0) { // eslint-disable-line no-unmodified-loop-condition
        await runBatch();
      }

      toast.success(`Started ${success} trips${fail ? `, ${fail} failed` : ''}`);
      setStatusFilter('running');
      setViewMode('live');
      setDateFilter(targetDateStr);
      await fetchData();
    } catch (e) {
      console.error(e);
      toast.error('Failed to start trips');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Streamlined Trip Management</h1>
          <p className="text-gray-600">Efficient trip scheduling and management</p>
        </div>
        <div className="flex items-center space-x-3">
          {/* Quick date picker for scheduling/filtering */}
          <input
            type="date"
            value={dateFilter}
            onChange={(e) => setDateFilter(e.target.value)}
            className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            title="Select date to filter and schedule"
          />
          <button
            onClick={fetchData}
            className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors flex items-center space-x-2"
          >
            <RefreshCw className="w-4 h-4" />
            <span>Refresh</span>
          </button>
          <button
            onClick={() => { if (viewMode !== 'live') { setViewMode('live'); fetchData(); } else { setViewMode('all'); fetchData(); } }}
            className={`px-4 py-2 rounded-lg transition-colors flex items-center space-x-2 ${viewMode === 'live' ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-green-50 text-green-700 hover:bg-green-100'}`}
            title="Show trips currently running"
          >
            <Play className="w-4 h-4" />
            <span>{viewMode === 'live' ? 'Live: On' : 'Live Trips'}</span>
          </button>
          <button
            onClick={() => startTripsForDate(dateFilter || new Date().toISOString().slice(0,10))}
            className="px-4 py-2 bg-green-100 text-green-700 rounded-lg hover:bg-green-200 transition-colors flex items-center space-x-2"
            title="Start all scheduled trips for the selected date"
          >
            <Play className="w-4 h-4" />
            <span>Start All (Date)</span>
          </button>
        </div>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm font-medium text-gray-600">Total Trips</p>
              <p className="text-2xl font-bold text-gray-900">{statsCounts.total || total}</p>
            </div>
            <div className="p-3 bg-blue-100 rounded-lg">
              <Calendar className="w-6 h-6 text-blue-600" />
            </div>
          </div>
        </div>
        
        <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 cursor-pointer" onClick={() => { setStatusFilter('scheduled'); setViewMode('all'); }}>
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm font-medium text-gray-600">Scheduled</p>
              <p className="text-2xl font-bold text-blue-600">{statsCounts.scheduled}</p>
            </div>
            <div className="p-3 bg-blue-100 rounded-lg">
              <Clock className="w-6 h-6 text-blue-600" />
            </div>
          </div>
        </div>
        
        <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 cursor-pointer" onClick={() => { setStatusFilter('running'); setViewMode('all'); }}>
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm font-medium text-gray-600">Running</p>
              <p className="text-2xl font-bold text-green-600">{statsCounts.running}</p>
            </div>
            <div className="p-3 bg-green-100 rounded-lg">
              <Play className="w-6 h-6 text-green-600" />
            </div>
          </div>
        </div>
        
        <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 cursor-pointer" onClick={() => { setStatusFilter('completed'); setViewMode('all'); }}>
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm font-medium text-gray-600">Completed</p>
              <p className="text-2xl font-bold text-gray-600">{statsCounts.completed}</p>
            </div>
            <div className="p-3 bg-gray-100 rounded-lg">
              <CheckCircle className="w-6 h-6 text-gray-600" />
            </div>
          </div>
        </div>
      </div>

      {/* Actions */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
        <div className="flex items-center justify-between mb-6">
          <h3 className="text-lg font-semibold text-gray-900">Quick Actions</h3>
          {selectedTrips.length > 0 && (
            <div className="flex items-center space-x-3">
              <span className="text-sm text-gray-600">{selectedTrips.length} trips selected</span>
            </div>
          )}
        </div>
        
        {/* All Quick Actions in One Line - Balanced Size */}
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-7 gap-3">
          <button
            onClick={() => setShowSingleAddModal(true)}
            className="p-3 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-blue-100 rounded-lg">
              <Plus className="w-5 h-5 text-blue-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-blue-900">Add Trip</h4>
              <p className="text-xs text-blue-700">Single trip</p>
            </div>
          </button>
          
          <button
            onClick={() => setShowRouteBuilder(true)}
            className="p-3 bg-purple-50 rounded-lg hover:bg-purple-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-purple-100 rounded-lg">
              <Route className="w-5 h-5 text-purple-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-purple-900">Route Builder</h4>
              <p className="text-xs text-purple-700">Auto-stops</p>
            </div>
          </button>
          
          <button
            onClick={handleExportTrips}
            className="p-3 bg-orange-50 rounded-lg hover:bg-orange-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-orange-100 rounded-lg">
              <Download className="w-5 h-5 text-orange-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-orange-900">Export</h4>
              <p className="text-xs text-orange-700">Trip data</p>
            </div>
          </button>

          <button
            onClick={handleScheduleToYearEnd}
            className="p-3 bg-emerald-50 rounded-lg hover:bg-emerald-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-emerald-100 rounded-lg">
              <Calendar className="w-5 h-5 text-emerald-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-emerald-900">Schedule to Year End</h4>
              <p className="text-xs text-emerald-700">Auto-assign all days</p>
            </div>
          </button>

          <button
            onClick={handleGenerate4PerDepot}
            className="p-3 bg-indigo-50 rounded-lg hover:bg-indigo-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-indigo-100 rounded-lg">
              <Calendar className="w-5 h-5 text-indigo-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-indigo-900">4/Depot</h4>
              <p className="text-xs text-indigo-700">Auto-assign</p>
            </div>
          </button>

          <button
            onClick={async () => {
              try {
                setLoading(true);
                const today = new Date().toISOString().slice(0,10);
                let res = await apiFetch('/api/trip-generator/finalize-schedule', { method: 'POST', body: JSON.stringify({ date: dateFilter || today }), suppressError: true });
                if (!(res?.success || res?.ok)) {
                  // Fallback to admin endpoint if trip-generator route not found
                  res = await apiFetch('/api/admin/trips/finalize', { method: 'POST', body: JSON.stringify({ date: dateFilter || today }) });
                }
                if (res?.success || res?.ok) {
                  toast.success('Schedule finalized');
                  await fetchData();
                } else {
                  toast.error(res?.message || 'Failed to finalize schedule');
                }
              } catch (e) {
                console.error(e);
                toast.error('Failed to finalize schedule');
              } finally {
                setLoading(false);
              }
            }}
            className="p-3 bg-emerald-50 rounded-lg hover:bg-emerald-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-emerald-100 rounded-lg">
              <UserCheck className="w-5 h-5 text-emerald-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-emerald-900">Finalize</h4>
              <p className="text-xs text-emerald-700">Assign all</p>
            </div>
          </button>

          <button
            onClick={() => setShowAutoSchedulerModal(true)}
            className="p-3 bg-purple-50 rounded-lg hover:bg-purple-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-purple-100 rounded-lg">
              <Sparkles className="w-5 h-5 text-purple-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-purple-900">Auto Scheduler</h4>
              <p className="text-xs text-purple-700">Mass scheduling</p>
            </div>
          </button>
          
          <button
            onClick={handleGenerate100Trips}
            className="p-3 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-blue-100 rounded-lg">
              <Calendar className="w-5 h-5 text-blue-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-blue-900">Generate</h4>
              <p className="text-xs text-blue-700">New trips</p>
            </div>
          </button>
          
          <button
            onClick={async () => {
              try {
                setLoading(true);
                const targetDate = dateFilter || '';
                const concurrency = 10;
                const scheduleIds = async (ids) => {
                  while (ids.length) {
                    const batch = ids.splice(0, concurrency);
                    await Promise.all(batch.map(id => apiFetch(`/api/admin/trips/${id}`, { method: 'PUT', body: JSON.stringify({ status: 'scheduled' }), suppressError: true })));
                  }
                };

                if (targetDate) {
                  // Schedule trips for selected date only
                  const d = new Date(targetDate);
                  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0).toISOString();
                  const end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999).toISOString();
                  const params = new URLSearchParams({ page: '1', limit: '2000', dateFrom: start, dateTo: end });
                  const listRes = await apiFetch('/api/admin/trips?' + params.toString(), { suppressError: true });
                  const payload = listRes?.data?.data || listRes?.data || {};
                  const allTrips = payload.trips || payload.data || [];
                  const toSchedule = (allTrips || []).filter(t => t.status !== 'scheduled' && t.status !== 'completed' && t.status !== 'cancelled');
                  const ids = toSchedule.map(t => t._id || t.id).filter(Boolean);
                  await scheduleIds(ids);
                  await startTripsForDate(targetDate);
                  toast.success('All trips for selected date scheduled and started');
                } else {
                  // Schedule ALL trips across database (paginate until all fetched)
                  const limitPerPage = 200;
                  let pageIdx = 1;
                  let total = 0;
                  let processed = 0;
                  do {
                    const params = new URLSearchParams({ page: String(pageIdx), limit: String(limitPerPage) });
                    const res = await apiFetch('/api/admin/trips?' + params.toString(), { suppressError: true });
                    const data = res?.data || {};
                    const tripsList = data?.data?.trips || data?.trips || [];
                    total = data?.data?.pagination?.total || data?.pagination?.total || total;
                    const ids = (tripsList || [])
                      .filter(t => t.status !== 'scheduled' && t.status !== 'completed' && t.status !== 'cancelled')
                      .map(t => t._id || t.id)
                      .filter(Boolean);
                    await scheduleIds(ids);
                    processed += tripsList.length || 0;
                    pageIdx += 1;
                  } while (processed < (total || processed));
                  toast.success('All trips in the system set to scheduled');
                }
              } catch (e) { console.error(e); toast.error('Scheduling failed'); } finally { setLoading(false); }
            }}
            className="p-3 bg-green-50 rounded-lg hover:bg-green-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-green-100 rounded-lg">
              <Play className="w-5 h-5 text-green-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-green-900">Schedule All</h4>
              <p className="text-xs text-green-700">Today</p>
            </div>
          </button>

          <button
            onClick={async () => {
              try {
                if (!window.confirm('This will delete ALL trips from the database. Are you sure?')) {
                  return;
                }
                
                setLoading(true);
                toast.loading('Clearing all trips...', { id: 'clear-trips' });
                
                // Use the dedicated clear-only endpoint
                const response = await apiFetch('/api/trip-generator/clear-all', {
                  method: 'POST'
                });
                
                if (response?.success) {
                  // Don't create new trips, just clear
                  toast.success('All trips cleared successfully!', { id: 'clear-trips' });
                  // Refresh the data to show empty state
                  await fetchData();
                } else {
                  toast.error(response?.error || 'Failed to clear trips', { id: 'clear-trips' });
                }
              } catch (error) {
                console.error('Error clearing trips:', error);
                toast.error('Failed to clear trips', { id: 'clear-trips' });
              } finally {
                setLoading(false);
              }
            }}
            className="p-3 bg-red-50 rounded-lg hover:bg-red-100 transition-colors flex flex-col items-center space-y-2"
          >
            <div className="p-2 bg-red-100 rounded-lg">
              <Trash2 className="w-5 h-5 text-red-600" />
            </div>
            <div className="text-center">
              <h4 className="text-sm font-semibold text-red-900">Clear All</h4>
              <p className="text-xs text-red-700">Delete all trips</p>
            </div>
          </button>
        </div>
      </div>

      {/* Filters */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Search</label>
            <div className="relative">
              <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
              <input
                type="text"
                placeholder="Search trips..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Status</label>
            <select
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            >
              <option value="all">All Status</option>
              <option value="scheduled">Scheduled</option>
              <option value="boarding">Boarding</option>
              <option value="running">Running</option>
              <option value="completed">Completed</option>
              <option value="cancelled">Cancelled</option>
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Date</label>
            <input
              type="date"
              value={dateFilter}
              onChange={(e) => setDateFilter(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>
          
          <div className="flex items-end">
            <button
              onClick={() => {
                setSearchTerm('');
                setStatusFilter('all');
                setDateFilter('');
                setRouteFilter('all');
                setPage(1);
              }}
              className="w-full px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors flex items-center justify-center space-x-2"
            >
              <Filter className="w-4 h-4" />
              <span>Clear Filters</span>
            </button>
          </div>
        </div>
      </div>

      {/* Pagination */}
      <div className="flex items-center justify-between mb-2">
        <div className="text-sm text-gray-600">{total} total · Page {page}</div>
        <div className="flex items-center space-x-2">
          <button onClick={() => setPage(p => Math.max(1, p - 1))} disabled={page === 1} className="px-2 py-1 border rounded disabled:opacity-50">Prev</button>
          <select value={limit} onChange={(e) => { setPage(1); setLimit(parseInt(e.target.value) || 24); }} className="px-2 py-1 border rounded">
            {[12,24,48,96].map(n => <option key={n} value={n}>{n}/page</option>)}
          </select>
          <button onClick={() => setPage(p => p + 1)} disabled={trips.length < limit && page * limit >= total} className="px-2 py-1 border rounded disabled:opacity-50">Next</button>
        </div>
      </div>

      {/* Trip Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredTrips.map(trip => (
          <TripCard key={trip._id} trip={trip} />
        ))}
      </div>

      {filteredTrips.length === 0 && (
        <div className="text-center py-12">
          <Calendar className="w-12 h-12 text-gray-400 mx-auto mb-4" />
          <h3 className="text-lg font-semibold text-gray-900 mb-2">No trips found</h3>
          <p className="text-gray-600">Try adjusting your search or create some trips.</p>
        </div>
      )}

      {/* Modals */}
      <AutoSchedulerModal />
      <RouteBuilderModal key="route-builder-modal" />
      {showAssignModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 w-full max-w-xl mx-4 max-h-[90vh] overflow-y-auto">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-semibold text-gray-900 flex items-center space-x-2">
                {assignMode === 'now' ? <UserCheck className="w-5 h-5 text-purple-600" /> : <CalendarDays className="w-5 h-5 text-gray-700" />}
                <span>{assignMode === 'now' ? 'Assign Now' : 'Assign for Specific Date'}</span>
              </h3>
              <button onClick={() => setShowAssignModal(false)} className="p-1 text-gray-500 hover:text-gray-700">
                <X className="w-5 h-5" />
              </button>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm text-gray-600 mb-1">Route *</label>
                <select value={assignForm.routeId} onChange={e => setAssignForm({ ...assignForm, routeId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select route</option>
                  {routes.map(r => <option key={r._id} value={r._id}>{r.routeNumber} - {r.routeName} ({r.startPlace || r.startingPoint?.location || r.startingPoint?.city} → {r.endPlace || r.endingPoint?.location || r.endingPoint?.city})</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Bus *</label>
                <select value={assignForm.busId} onChange={e => setAssignForm({ ...assignForm, busId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select bus</option>
                  {buses.map(b => <option key={b._id} value={b._id}>{b.busNumber}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Driver *</label>
                <select value={assignForm.driverId} onChange={e => setAssignForm({ ...assignForm, driverId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select driver</option>
                  {drivers.map(d => <option key={d._id} value={d._id}>{d.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Date *</label>
                <input type="date" value={assignForm.scheduledDate} onChange={e => setAssignForm({ ...assignForm, scheduledDate: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Time *</label>
                <div className="relative">
                  <Timer className="w-4 h-4 absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
                  <input type="time" value={assignForm.scheduledTime} onChange={e => setAssignForm({ ...assignForm, scheduledTime: e.target.value })} className="w-full pl-9 border rounded-lg px-3 py-2" />
                </div>
              </div>
            </div>
            <div className="flex justify-end space-x-3 mt-6">
              <button onClick={() => setShowAssignModal(false)} className="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
              <button onClick={handleAssignSubmit} className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">Assign</button>
            </div>
          </div>
        </div>
      )}
      
      {/* Single Add Trip Modal */}
      {showSingleAddModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 w-full max-w-3xl mx-4 max-h-[90vh] overflow-y-auto">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-semibold text-gray-900">Add Single Trip</h3>
              <button onClick={() => setShowSingleAddModal(false)} className="p-1 text-gray-500 hover:text-gray-700">
                <X className="w-5 h-5" />
              </button>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm text-gray-600 mb-1">Route *</label>
                <select value={tripForm.routeId} onChange={e => setTripForm({ ...tripForm, routeId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select route</option>
                  {routes.map(r => <option key={r._id} value={r._id}>{r.routeNumber} - {r.routeName} ({r.startPlace || r.startingPoint?.location || r.startingPoint?.city} → {r.endPlace || r.endingPoint?.location || r.endingPoint?.city})</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Bus</label>
                <select value={tripForm.busId} onChange={e => setTripForm({ ...tripForm, busId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select bus</option>
                  {buses.map(b => <option key={b._id} value={b._id}>{b.busNumber} ({b.capacity?.total || 0} seats)</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Driver</label>
                <select value={tripForm.driverId} onChange={e => setTripForm({ ...tripForm, driverId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select driver</option>
                  {drivers.map(d => <option key={d._id} value={d._id}>{d.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Conductor</label>
                <select value={tripForm.conductorId} onChange={e => setTripForm({ ...tripForm, conductorId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select conductor</option>
                  {conductors.map(c => <option key={c._id} value={c._id}>{c.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Service Date *</label>
                <input type="date" value={tripForm.serviceDate} onChange={e => setTripForm({ ...tripForm, serviceDate: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Start Time *</label>
                <input type="time" value={tripForm.startTime} onChange={e => setTripForm({ ...tripForm, startTime: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">End Time</label>
                <input type="time" value={tripForm.endTime} onChange={e => setTripForm({ ...tripForm, endTime: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Fare (₹)</label>
                <input type="number" value={tripForm.fare} onChange={e => setTripForm({ ...tripForm, fare: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Capacity</label>
                <input type="number" value={tripForm.capacity} onChange={e => setTripForm({ ...tripForm, capacity: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Status</label>
                <select value={tripForm.status} onChange={e => setTripForm({ ...tripForm, status: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="scheduled">Scheduled</option>
                  <option value="boarding">Boarding</option>
                  <option value="running">Running</option>
                  <option value="completed">Completed</option>
                  <option value="cancelled">Cancelled</option>
                </select>
              </div>
            </div>
            <div className="flex justify-end space-x-3 mt-6">
              <button onClick={() => setShowSingleAddModal(false)} className="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
              <button onClick={handleSingleTripAdd} className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Add Trip</button>
            </div>
          </div>
        </div>
      )}

      {/* Edit Trip Modal */}
      {showEditModal && selectedTrip && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 w-full max-w-3xl mx-4 max-h-[90vh] overflow-y-auto">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-semibold text-gray-900">Edit Trip</h3>
              <button onClick={() => setShowEditModal(false)} className="p-1 text-gray-500 hover:text-gray-700">
                <X className="w-5 h-5" />
              </button>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm text-gray-600 mb-1">Route *</label>
                <select value={tripForm.routeId} onChange={e => setTripForm({ ...tripForm, routeId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select route</option>
                  {routes.map(r => <option key={r._id} value={r._id}>{r.routeNumber} - {r.routeName} ({r.startPlace || r.startingPoint?.location || r.startingPoint?.city} → {r.endPlace || r.endingPoint?.location || r.endingPoint?.city})</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Bus</label>
                <select value={tripForm.busId} onChange={e => setTripForm({ ...tripForm, busId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select bus</option>
                  {buses.map(b => <option key={b._id} value={b._id}>{b.busNumber} ({b.capacity?.total || 0} seats)</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Driver</label>
                <select value={tripForm.driverId} onChange={e => setTripForm({ ...tripForm, driverId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select driver</option>
                  {drivers.map(d => <option key={d._id} value={d._id}>{d.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Conductor</label>
                <select value={tripForm.conductorId} onChange={e => setTripForm({ ...tripForm, conductorId: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="">Select conductor</option>
                  {conductors.map(c => <option key={c._id} value={c._id}>{c.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Service Date *</label>
                <input type="date" value={tripForm.serviceDate} onChange={e => setTripForm({ ...tripForm, serviceDate: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Start Time *</label>
                <input type="time" value={tripForm.startTime} onChange={e => setTripForm({ ...tripForm, startTime: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">End Time</label>
                <input type="time" value={tripForm.endTime} onChange={e => setTripForm({ ...tripForm, endTime: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Fare (₹)</label>
                <input type="number" value={tripForm.fare} onChange={e => setTripForm({ ...tripForm, fare: e.target.value })} className="w-full border rounded-lg px-3 py-2" />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">Status</label>
                <select value={tripForm.status} onChange={e => setTripForm({ ...tripForm, status: e.target.value })} className="w-full border rounded-lg px-3 py-2">
                  <option value="scheduled">Scheduled</option>
                  <option value="boarding">Boarding</option>
                  <option value="running">Running</option>
                  <option value="completed">Completed</option>
                  <option value="cancelled">Cancelled</option>
                </select>
              </div>
            </div>
            <div className="flex justify-end space-x-3 mt-6">
              <button onClick={() => setShowEditModal(false)} className="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
              <button onClick={handleUpdateTrip} className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save Changes</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default StreamlinedTripManagement;

